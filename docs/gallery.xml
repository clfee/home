<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Chris Lee</title>
<link>https://github.com/clfee/website/gallery.html</link>
<atom:link href="https://github.com/clfee/website/gallery.xml" rel="self" type="application/rss+xml"/>
<description></description>
<generator>quarto-1.4.554</generator>
<lastBuildDate>Mon, 15 Jul 2024 05:00:00 GMT</lastBuildDate>
<item>
  <title></title>
  <dc:creator>Chris Lee</dc:creator>
  <link>https://github.com/clfee/website/posts/2024-07-15-market-compaign/</link>
  <description><![CDATA[ undefined ]]></description>
  <guid>https://github.com/clfee/website/posts/2024-07-15-market-compaign/</guid>
  <pubDate>Mon, 15 Jul 2024 05:00:00 GMT</pubDate>
</item>
<item>
  <title>Image Classification (Part2)</title>
  <dc:creator>Chris Lee</dc:creator>
  <link>https://github.com/clfee/website/posts/2021-08-31-malaria-cell-classification - p2/</link>
  <description><![CDATA[ 




<p>When building a predictive model, there are two important criteria: predictive accuracy and interpretability, which generally have a trade-off relationship. In the previous <a href="https://clfee.github.io/python/image/classification/image-classification1">post</a>, we have shown that the DenseNet121 model can achieve high accuracy in detecting cells infected with parasites.</p>
<p>Here, I am going to introduce a powerful technique GRAD-CAM (gradient-weighted class activation mapping) to visualize which parts of an image are most important to the predictions of an image regression network. GRAD-CAM is a generalization of the CAM technique which determines the importance of each neuron in a network prediction by considering the gradients of the target flowing through the deep network. Unlike CAM which requires a particular kind of CNN architecture to perform global average pooling prior to prediction and forces us to change the base model retrain the network. In contrast, GRAD-CAM is accessing intermediate activations in the deep learning model and computing gradients with respect to the class output. For more details, please <a href="https://www.coursera.org/lecture/advanced-computer-vision-with-tensorflow/gradcam-u1Qub">see</a>.</p>
<p>Workflow: - Obtain predicted class/index - Determine which intermediate layer(s) to use. Lower-level convolution layers capture low level features such as edges, and lines. Higher-level layers usually have more abstract information. - Calculate the gradients with respect to the outout of the class/index - Generate a heatmap by weighing the convolution outputs with the computed gradients - Super-impose the heatmap to the original image</p>
<p><em>Load base model</em></p>
<p>We first load the base model and will only train the last 4 layers.</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode yml code-with-copy"><code class="sourceCode yaml"><span id="cb1-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">def build_model(input_shape=(224, 224,3),pos_weights,neg_weights)</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span></span>
<span id="cb1-2"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  # load the base DenseNet121 model</span></span>
<span id="cb1-3"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">  base_model = DenseNet121(input_shape = input_shape, </span></span>
<span id="cb1-4"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">                      weights='imagenet', </span></span>
<span id="cb1-5"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">                      include_top=False)</span></span>
<span id="cb1-6"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">  </span></span>
<span id="cb1-7"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  # add a GAP layer</span></span>
<span id="cb1-8"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">  output = layers.GlobalAveragePooling2D()(base_model.output)</span></span>
<span id="cb1-9"></span>
<span id="cb1-10"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  # output has two neurons for the 2 classes (uninfected and parasite)</span></span>
<span id="cb1-11"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">  output = layers.Dense(2, activation='softmax')(output)</span></span>
<span id="cb1-12"></span>
<span id="cb1-13"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  # set the inputs and outputs of the model</span></span>
<span id="cb1-14"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">  model = Model(base_model.input, output)</span></span>
<span id="cb1-15"></span>
<span id="cb1-16"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  # freeze the earlier layers</span></span>
<span id="cb1-17"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">  for layer in base_model.layers[</span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">:-4]</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span></span>
<span id="cb1-18"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">      layer.trainable=False</span></span>
<span id="cb1-19"></span>
<span id="cb1-20"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">  # configure the model for training</span></span>
<span id="cb1-21"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">  model.compile(loss= get_weighted_loss(neg_weights, pos_weights), </span></span>
<span id="cb1-22"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">                optimizer=adam, </span></span>
<span id="cb1-23"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">                metrics=['accuracy'])</span></span>
<span id="cb1-24"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">  </span></span>
<span id="cb1-25"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">  return model</span></span>
<span id="cb1-26"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> </span></span></code></pre></div>
<p>We then create a new model that has the original model’s inputs, but two different outputs. The first output contains the activation layers outputs that in this case is the final convolutional layer in the original model. And the second output is the model’s prediction for the image.</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode yml code-with-copy"><code class="sourceCode yaml"><span id="cb2-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">def get_CAM(model, processed_image, actual_label, layer_name)</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> </span></span>
<span id="cb2-2"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    </span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">""</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">"</span></span>
<span id="cb2-3"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    GradCAM method for visualizing input saliency.</span></span>
<span id="cb2-4"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    </span></span>
<span id="cb2-5"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">Args</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span></span>
<span id="cb2-6"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">model (Keras.model)</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> model to compute cam for</span></span>
<span id="cb2-7"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">image (tensor)</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> input to model, shape (1, H, W, 3)</span></span>
<span id="cb2-8"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">cls (int)</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> class to compute cam with respect to</span></span>
<span id="cb2-9"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">layer_name (str)</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> relevant layer in model</span></span>
<span id="cb2-10"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">H (int)</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> input height</span></span>
<span id="cb2-11"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">W (int)</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> input width</span></span>
<span id="cb2-12"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">Return</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span></span>
<span id="cb2-13"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        heatmap()</span></span>
<span id="cb2-14"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    </span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">""</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">"    </span></span>
<span id="cb2-15"></span>
<span id="cb2-16"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    model_grad = Model([model.inputs], </span></span>
<span id="cb2-17"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">                       </span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">[</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">model.get_layer(layer_name).output</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">,</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> model.output</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">]</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">)</span></span>
<span id="cb2-18"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    </span></span>
<span id="cb2-19"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">    </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">with tf.GradientTape() as tape</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span></span>
<span id="cb2-20"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        conv_output_values, predictions = model_grad(processed_image)</span></span>
<span id="cb2-21"></span>
<span id="cb2-22"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">        # assign gradient tape to monitor the conv_output</span></span>
<span id="cb2-23"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        tape.watch(conv_output_values)</span></span>
<span id="cb2-24"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        </span></span>
<span id="cb2-25"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">        # use binary cross entropy loss, actual_label = 0 if uninfected</span></span>
<span id="cb2-26"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">        # get prediction probability of infected  </span></span>
<span id="cb2-27"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        pred_prob = predictions[:,1] </span></span>
<span id="cb2-28"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        </span></span>
<span id="cb2-29"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">        # make sure actual_label is a float, like the rest of the loss calculation</span></span>
<span id="cb2-30"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        actual_label = tf.cast(actual_label, dtype=tf.float32)</span></span>
<span id="cb2-31"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        </span></span>
<span id="cb2-32"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">        # add a tiny value to avoid log of 0</span></span>
<span id="cb2-33"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        smoothing = 0.00001 </span></span>
<span id="cb2-34"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        </span></span>
<span id="cb2-35"><span class="co" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">        # Calculate loss as binary cross entropy</span></span>
<span id="cb2-36"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        loss = -1 * (actual_label * tf.math.log(pred_prob + smoothing) + (1 - actual_label) * tf.math.log(1 - pred_prob + smoothing))</span></span>
<span id="cb2-37"><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">        </span><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">print(f"binary loss</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">:</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;"> </span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">{</span><span class="at" style="color: #657422;
background-color: null;
font-style: inherit;">loss</span><span class="kw" style="color: #003B4F;
background-color: null;
font-style: inherit;">}</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">")</span></span>
<span id="cb2-38"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    </span></span>
<span id="cb2-39"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    # get the gradient of the loss with respect to the outputs of the last conv layer</span></span>
<span id="cb2-40"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    grads_values = tape.gradient(loss, conv_output_values)</span></span>
<span id="cb2-41"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    grads_values = K.mean(grads_values, axis=(0,1,2))</span></span>
<span id="cb2-42"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    </span></span>
<span id="cb2-43"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    conv_output_values = np.squeeze(conv_output_values.numpy())</span></span>
<span id="cb2-44"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    grads_values = grads_values.numpy()</span></span>
<span id="cb2-45"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    </span></span>
<span id="cb2-46"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    # weight the convolution outputs with the computed gradients</span></span>
<span id="cb2-47"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    for i in range(grads_values.shape[-1]): </span></span>
<span id="cb2-48"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">        conv_output_values[:,:,i] *= grads_values[i]</span></span>
<span id="cb2-49"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    heatmap = np.mean(conv_output_values, axis=-1)</span></span>
<span id="cb2-50"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    </span></span>
<span id="cb2-51"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    heatmap = np.maximum(heatmap, 0)</span></span>
<span id="cb2-52"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    heatmap /= heatmap.max()</span></span>
<span id="cb2-53"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    </span></span>
<span id="cb2-54"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    del model_grad, conv_output_values, grads_values, loss</span></span>
<span id="cb2-55"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">   </span></span>
<span id="cb2-56"><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">    return heatmap</span></span></code></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/clfee/website/assets/images/gradcam_res.PNG" class="img-fluid figure-img"></p>
<figcaption>Result</figcaption>
</figure>
</div>
<p>Note: Instead of using max pooling that only keeps the highest valued ones. Average pooling allows some of the lesser intensity pixels to pass on in the pooling layer. It is important as we look at the small size of the image once it reaches this layer, max pooling could leave us with very little information.</p>



<a onclick="window.scrollTo(0, 0); return false;" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a> ]]></description>
  <category>python</category>
  <category>Image Classification</category>
  <guid>https://github.com/clfee/website/posts/2021-08-31-malaria-cell-classification - p2/</guid>
  <pubDate>Tue, 31 Aug 2021 05:00:00 GMT</pubDate>
</item>
<item>
  <title></title>
  <dc:creator>Chris Lee</dc:creator>
  <link>https://github.com/clfee/website/posts/2021-08-31-malaria-cell-classification/</link>
  <description><![CDATA[ undefined ]]></description>
  <category>python</category>
  <category>Image Classification</category>
  <guid>https://github.com/clfee/website/posts/2021-08-31-malaria-cell-classification/</guid>
  <pubDate>Tue, 31 Aug 2021 05:00:00 GMT</pubDate>
</item>
</channel>
</rss>
